From 8935cbe34c535370fb5f33df78737e77704605d4 Mon Sep 17 00:00:00 2001
From: Antonio Gomes <tonikitoo@igalia.com>
Date: Tue, 17 May 2016 12:45:48 -0400
Subject: [PATCH] Port minimal files from Ozone/Wayland needed for desktop-mode
 content_shell builds

Namely, these are the files "ported" from https://github.com/01org/ozone-wayland:

- ui/views/widget/desktop_aura/desktop_drag_drop_client_wayland.cc / h
- ui/views/widget/desktop_aura/desktop_screen_ozone_wayland.cc / h
- ui/views/widget/desktop_aura/desktop_window_tree_host_ozone_wayland.cc / h

Some tweaks were needed in order for them to build.

Amend from Fred Wang <fwang@igalia.com>:

fixup! Port minimal files from Ozone/Wayland needed for desktop-mode content_shell builds

Amend from Antonio Gomes <tonikitoo@igalia.com>

fixup! Port minimal files from Ozone/Wayland needed for desktop-mode content_shell builds
---
 ui/views/BUILD.gn                                  |    8 +
 .../desktop_drag_drop_client_wayland.cc            |  506 ++++++++++
 .../desktop_drag_drop_client_wayland.h             |  185 ++++
 .../desktop_aura/desktop_factory_ozone_stubs.cc    |   17 +
 .../desktop_aura/desktop_factory_ozone_stubs.h     |   17 +
 .../desktop_aura/desktop_factory_ozone_wayland.cc  |    6 +-
 .../desktop_aura/desktop_screen_ozone_wayland.cc   |  163 +++
 .../desktop_aura/desktop_screen_ozone_wayland.h    |   68 ++
 .../desktop_window_tree_host_ozone_wayland.cc      | 1061 ++++++++++++++++++++
 .../desktop_window_tree_host_ozone_wayland.h       |  228 +++++
 10 files changed, 2257 insertions(+), 2 deletions(-)
 create mode 100644 ui/views/widget/desktop_aura/desktop_drag_drop_client_wayland.cc
 create mode 100644 ui/views/widget/desktop_aura/desktop_drag_drop_client_wayland.h
 create mode 100644 ui/views/widget/desktop_aura/desktop_factory_ozone_stubs.cc
 create mode 100644 ui/views/widget/desktop_aura/desktop_factory_ozone_stubs.h
 create mode 100644 ui/views/widget/desktop_aura/desktop_screen_ozone_wayland.cc
 create mode 100644 ui/views/widget/desktop_aura/desktop_screen_ozone_wayland.h
 create mode 100644 ui/views/widget/desktop_aura/desktop_window_tree_host_ozone_wayland.cc
 create mode 100644 ui/views/widget/desktop_aura/desktop_window_tree_host_ozone_wayland.h

diff --git a/ui/views/BUILD.gn b/ui/views/BUILD.gn
index 0f35ca3..60f529f 100644
--- a/ui/views/BUILD.gn
+++ b/ui/views/BUILD.gn
@@ -626,6 +626,14 @@ component("views") {
         sources += [ constructor_list_cc_file ]
         if (ozone_platform_wayland) {
           sources += [
+            "widget/desktop_aura/desktop_drag_drop_client_wayland.cc",
+            "widget/desktop_aura/desktop_drag_drop_client_wayland.h",
+            "widget/desktop_aura/desktop_screen_ozone_wayland.cc",
+            "widget/desktop_aura/desktop_screen_ozone_wayland.h",
+            "widget/desktop_aura/desktop_window_tree_host_ozone_wayland.cc",
+            "widget/desktop_aura/desktop_window_tree_host_ozone_wayland.h",
+            "widget/desktop_aura/desktop_factory_ozone_stubs.cc",
+            "widget/desktop_aura/desktop_factory_ozone_stubs.h",
             "widget/desktop_aura/desktop_factory_ozone_wayland.cc",
             "widget/desktop_aura/desktop_factory_ozone_wayland.h",
           ]
diff --git a/ui/views/widget/desktop_aura/desktop_drag_drop_client_wayland.cc b/ui/views/widget/desktop_aura/desktop_drag_drop_client_wayland.cc
new file mode 100644
index 0000000..869be13
--- /dev/null
+++ b/ui/views/widget/desktop_aura/desktop_drag_drop_client_wayland.cc
@@ -0,0 +1,506 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/widget/desktop_aura/desktop_drag_drop_client_wayland.h"
+
+#include <algorithm>
+#include <iterator>
+
+#include "base/files/file_path.h"
+#include "base/strings/string16.h"
+#include "base/strings/string_split.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/threading/thread_restrictions.h"
+#include "content/public/browser/browser_thread.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/dragdrop/drop_target_event.h"
+#include "ui/base/dragdrop/file_info.h"
+#include "ui/base/dragdrop/os_exchange_data_provider_aura.h"
+#include "ui/platform_window/platform_window.h"
+
+// TODO(mcatanzaro): Add support for accepting drags from GTK+ and Qt.
+// Currently, only drags from the reference weston-dnd client are supported.
+//
+// We will need changes in both Wayland and GTK+ to support drags from GTK+.
+//
+// See: https://bugs.freedesktop.org/show_bug.cgi?id=91944
+//
+// Also relevant: https://bugs.freedesktop.org/show_bug.cgi?id=91945
+//
+// I have not tested Qt yet.
+
+// TODO(mcatanzaro): Add support for drags originating from Chrome. Currently,
+// only drags into Chrome from another process are supported.
+
+namespace views {
+
+namespace {
+
+auto& kMimeTypeText = ui::Clipboard::kMimeTypeText;
+auto& kMimeTypeURIList = ui::Clipboard::kMimeTypeURIList;
+
+const char kMimeTypeTextUTF8[] = "text/plain;charset=utf-8";
+
+void AddStringToOSExchangeData(ui::OSExchangeData* os_exchange_data,
+                               const std::string& data) {
+  if (data.empty())
+    return;
+
+  base::string16 string16 = base::UTF8ToUTF16(data);
+  os_exchange_data->SetString(string16);
+
+  VLOG(1) << "Added string " << string16 << " to OSExchangeData";
+}
+
+void AddURIListToOSExchangeData(ui::OSExchangeData* os_exchange_data,
+                                const std::string& data) {
+  std::vector<std::string> filenames = base::SplitString(
+      data,
+      "\n",
+      base::TRIM_WHITESPACE,
+      base::SPLIT_WANT_NONEMPTY);
+
+  // The URI list is allowed to contain comments, which need to be removed.
+  auto new_end = std::remove_if(filenames.begin(), filenames.end(),
+                                [](const std::string& value) {
+                                    return value.empty() || value[0] == '#';
+                                });
+  filenames.erase(new_end, filenames.end());
+
+  if (filenames.empty())
+    return;
+
+  std::vector<ui::FileInfo> file_infos;
+  for (std::string& filename : filenames) {
+    ui::FileInfo file;
+    file.path = base::FilePath::FromUTF8Unsafe(filename);
+    file_infos.push_back(file);
+    VLOG(1) << "Adding filename " << filename << " to OSExchangeData";
+  }
+
+  os_exchange_data->SetFilenames(file_infos);
+}
+
+void AddToOSExchangeData(ui::OSExchangeData* os_exchange_data,
+                         const std::string& data,
+                         const std::string& mime_type) {
+  VLOG(2) <<  __FUNCTION__ << " data=" << data << " mime_type=" << mime_type;
+
+  if ((mime_type == kMimeTypeText || mime_type == kMimeTypeTextUTF8)) {
+    DCHECK(!os_exchange_data->HasString());
+    AddStringToOSExchangeData(os_exchange_data, data);
+    return;
+  }
+
+  if (mime_type == kMimeTypeURIList) {
+    DCHECK(!os_exchange_data->HasFile());
+    AddURIListToOSExchangeData(os_exchange_data, data);
+    return;
+  }
+
+  NOTREACHED();
+}
+
+}  // namespace
+
+DesktopDragDropClientWayland::DragDataCollector::DragDataCollector(
+    base::WeakPtr<DesktopDragDropClientWayland> drag_drop_client,
+    const std::vector<std::string>& mime_types,
+    gfx::AcceleratedWidget windowhandle)
+    : drag_drop_client_(drag_drop_client),
+      os_exchange_data_(base::MakeUnique<ui::OSExchangeDataProviderAura>()) {
+  std::copy(mime_types.begin(),
+            mime_types.end(),
+            std::insert_iterator<std::list<std::string>>(
+                unprocessed_mime_types_,
+                unprocessed_mime_types_.begin()));
+}
+
+DesktopDragDropClientWayland::DragDataCollector::~DragDataCollector() {
+  if (pipefd_)
+    close(pipefd_);
+}
+
+void DesktopDragDropClientWayland::DragDataCollector::SetPipeFd(int pipefd) {
+  DCHECK(!IsReadingData());
+  pipefd_ = pipefd;
+}
+
+bool DesktopDragDropClientWayland::DragDataCollector::IsReadingData() const {
+  return !!pipefd_;
+}
+
+void DesktopDragDropClientWayland::DragDataCollector::HandleNextMimeType() {
+  DCHECK(!IsReadingData());
+
+  if (!drag_drop_client_)
+    return;
+
+  std::string mime_type = SelectNextMimeType();
+  if (!mime_type.empty()) {
+    VLOG(1) << __FUNCTION__ << ": requesting data of MIME type " << mime_type;
+    drag_drop_client_->platform_window_.RequestDragData(mime_type);
+  } else {
+    drag_drop_client_->OnDragDataCollected(this);
+  }
+}
+
+// static
+void DesktopDragDropClientWayland::DragDataCollector::ReadDragData(
+    scoped_refptr<DragDataCollector> data_collector) {
+  VLOG(1) <<  __FUNCTION__ << " data_collector=" << data_collector.get();
+
+  base::ThreadRestrictions::AssertIOAllowed();
+
+  ssize_t bytes_read;
+  std::string data;
+  for (;;) {
+    char buffer[PIPE_BUF + 1];
+    bytes_read = HANDLE_EINTR(read(data_collector->GetPipeFd(),
+                                   buffer,
+                                   sizeof(buffer) - 1));
+    if (bytes_read == 0)
+      break;
+    if (bytes_read == -1)
+      break;
+    buffer[bytes_read] = '\0';
+    data += buffer;
+  }
+  close(data_collector->pipefd_);
+  data_collector->pipefd_ = 0;
+
+  DCHECK(!data_collector->unprocessed_mime_types_.empty());
+
+  if (!data.empty()) {
+    AddToOSExchangeData(&data_collector->os_exchange_data_,
+                        data,
+                        data_collector->unprocessed_mime_types_.front());
+
+    if (data_collector->first_received_mime_type_.empty()) {
+      data_collector->first_received_mime_type_ =
+          data_collector->unprocessed_mime_types_.front();
+    }
+  }
+
+  data_collector->unprocessed_mime_types_.erase(
+      data_collector->unprocessed_mime_types_.begin());
+
+  // TODO(tonikitoo): Fix it?
+  /*
+  content::BrowserThread::PostTask(
+      content::BrowserThread::UI,
+      FROM_HERE,
+      base::Bind(
+          &DesktopDragDropClientWayland::DragDataCollector::HandleNextMimeType,
+          data_collector.get()->AsWeakPtr()));
+  */
+}
+
+std::string
+DesktopDragDropClientWayland::DragDataCollector::SelectNextMimeType() {
+  // unprocessed_mime_types_ is a list instead of a vector to avoid repeatedly
+  // reallocating a vector when removing its first element in here. The
+  // performance impact would normally be insignificant, but it might matter if
+  // a malicious Wayland client offers a huge list of MIME types. We don't want
+  // to start from the last element of the list so as to prefer MIME types that
+  // occur earlier in the list.
+  while (!unprocessed_mime_types_.empty()) {
+    std::string& mime_type = unprocessed_mime_types_.front();
+    if (((mime_type == kMimeTypeText || mime_type == kMimeTypeTextUTF8) &&
+         !os_exchange_data_.HasString()) ||
+        (mime_type == kMimeTypeURIList && !os_exchange_data_.HasFile()))  {
+      return mime_type;
+    }
+    unprocessed_mime_types_.erase(unprocessed_mime_types_.begin());
+  }
+  return std::string();
+}
+
+DesktopDragDropClientWayland::DesktopDragDropClientWayland(
+    aura::Window* root_window, ui::PlatformWindow* platform_window)
+    : root_window_(*root_window),
+      platform_window_(*platform_window),
+      target_window_(nullptr),
+      delegate_(nullptr),
+      delayed_drop_location_(nullptr),
+      weak_ptr_factory_(this) {
+}
+
+DesktopDragDropClientWayland::~DesktopDragDropClientWayland() {
+}
+
+int DesktopDragDropClientWayland::StartDragAndDrop(
+    const ui::OSExchangeData& data,
+    aura::Window* root_window,
+    aura::Window* source_window,
+    const gfx::Point& root_location,
+    int operation,
+    ui::DragDropTypes::DragEventSource source) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+void DesktopDragDropClientWayland::DragCancel() {
+  NOTIMPLEMENTED();
+}
+
+bool DesktopDragDropClientWayland::IsDragDropInProgress() {
+  return !!windowhandle_;
+}
+
+void DesktopDragDropClientWayland::OnWindowDestroying(aura::Window* window) {
+  DCHECK_EQ(target_window_, window);
+  target_window_->RemoveObserver(this);
+  target_window_ = nullptr;
+}
+
+void DesktopDragDropClientWayland::OnDragEnter(
+    gfx::AcceleratedWidget windowhandle,
+    float x,
+    float y,
+    const std::vector<std::string>& mime_types,
+    uint32_t serial) {
+  VLOG(1) <<  __FUNCTION__ << " windowhandle=" << windowhandle
+           << " x=" << x << " y=" << y << " serial=" << serial;
+
+  if (data_collector_) {
+    // A previous drag ended before drag data was fully transferred, then this
+    // new drag started. Cancel the old drag before proceeding.
+    DragDropSessionCompleted();
+  }
+
+  if (windowhandle_) {
+    LOG(ERROR) << "Received DragEnter event during an outstanding drag.";
+    return;
+  }
+
+  if (!windowhandle || mime_types.empty()) {
+    LOG(ERROR) << "Received invalid DragEnter event from GPU process.";
+    return;
+  }
+
+  point_.SetPoint(x, y);
+
+  serial_ = serial;
+  windowhandle_ = windowhandle;
+
+  data_collector_ = new DragDataCollector(weak_ptr_factory_.GetWeakPtr(),
+                                          mime_types,
+                                          windowhandle);
+  data_collector_->HandleNextMimeType();
+
+  // From here on out, it's unsafe to modify the DragDataCollector from the
+  // browser thread until the DragDataCollector calls OnDragDataCollected.
+}
+
+void DesktopDragDropClientWayland::OnDragDataReceived(int pipefd) {
+  VLOG(1) <<  __FUNCTION__ << " pipefd=" << pipefd;
+
+  if (!data_collector_) {
+    // OnDragLeave has already been called.
+    close(pipefd);
+    return;
+  }
+
+  if (data_collector_->IsReadingData()) {
+    LOG(ERROR) << "Received DragData event during an outstanding read.";
+    close(pipefd);
+    return;
+  }
+
+  data_collector_->SetPipeFd(pipefd);
+
+  // TODO(tonikitoo): Fix it?
+  /*
+  content::BrowserThread::PostTask(
+      content::BrowserThread::FILE_USER_BLOCKING,
+      FROM_HERE,
+      base::Bind(&DesktopDragDropClientWayland::DragDataCollector::ReadDragData,
+                 data_collector_));
+  */
+}
+
+void DesktopDragDropClientWayland::OnDragLeave() {
+  VLOG(1) <<  __FUNCTION__;
+
+  // Wayland sends OnDragLeave after OnDragDrop, but the DragDropDelegate
+  // expects to receive only one or the other.
+  if (delegate_ && should_emit_drag_exited_)
+    delegate_->OnDragExited();
+
+  should_emit_drag_exited_ = true;
+
+  if (!delayed_drop_location_) {
+    DragDropSessionCompleted();
+  }
+
+  // TODO(mcatanzaro): It would be nice to support cancellation of the previous
+  // DragDataCollector's tasks. Otherwise, it's just going to keep on
+  // reading data until it finishes, blocking its thread. But this probably
+  // doesn't matter much, since the reading will usually be pretty fast.
+}
+
+void DesktopDragDropClientWayland::OnDragMotion(float x,
+                                                float y,
+                                                uint32_t time) {
+  VLOG(2) << __FUNCTION__ << " x=" << x << " y=" << y << " time=" << time;
+
+  point_.SetPoint(x, y);
+
+  if (!delegate_)
+    return;
+
+  std::unique_ptr<ui::DropTargetEvent> event = CreateDropTargetEvent();
+  if (event) {
+    bool shouldAcceptDrag = delegate_->OnDragUpdated(*event);
+
+    if (shouldAcceptDrag && !did_most_recently_accept_drag_)
+      IndicateDragWillBeAccepted();
+    else if (!shouldAcceptDrag && did_most_recently_accept_drag_)
+      IndicateDragWillBeRejected();
+  }
+}
+
+void DesktopDragDropClientWayland::OnDragDrop() {
+  VLOG(1) <<  __FUNCTION__;
+
+  if (delegate_) {
+    std::unique_ptr<ui::DropTargetEvent> event = CreateDropTargetEvent();
+    // All the drag data is available. This is the usual case.
+    delegate_->OnPerformDrop(*event);
+    should_emit_drag_exited_ = false;
+  } else if (target_window_) {
+    // Unlikely case: the drop could occur before all the drag data has been
+    // transferred from the source process. If so, we must delay the emission
+    // of the drop event until the data is available.
+    delayed_drop_location_.reset(new gfx::Point(point_.x(), point_.y()));
+    root_window_.GetHost()->ConvertScreenInPixelsToDIP(
+        delayed_drop_location_.get());
+  }
+}
+
+void DesktopDragDropClientWayland::IndicateDragWillBeAccepted() {
+  DCHECK(serial_);
+  DCHECK(data_collector_);
+  DCHECK(!data_collector_->first_received_mime_type().empty());
+
+  // TODO(mcatanzaro): https://bugs.freedesktop.org/show_bug.cgi?id=91950
+  // It is impossible to know which MIME type to accept, since DragDropDelegate
+  // does not provide this information. Since this won't affect the
+  // correctness of the drag (it is only to allow the source client to show a
+  // type-dependent cursor), we just send the first MIME type that we received
+  // data for. It would be better if Wayland would provide a way to indicate
+  // acceptance without specifying MIME type.
+  platform_window_.DragWillBeAccepted(
+      serial_,
+      data_collector_->first_received_mime_type());
+
+  did_most_recently_accept_drag_ = true;
+}
+
+void DesktopDragDropClientWayland::IndicateDragWillBeRejected() {
+  DCHECK(serial_);
+  platform_window_.DragWillBeRejected(serial_);
+
+  did_most_recently_accept_drag_ = false;
+}
+
+void DesktopDragDropClientWayland::OnDragDataCollected(
+    DragDataCollector* collector) {
+  VLOG(1) <<  __FUNCTION__ << " collector=" << collector;
+
+  // Make sure the drag has not already been cancelled. If it has been
+  // cancelled, then |data_collector_| will have been reset by OnDragLeave()
+  // and will not match |collector|.
+  if (data_collector_ != collector)
+    return;
+
+  // Did the other process actually send data?
+  if (collector->first_received_mime_type().empty()) {
+    IndicateDragWillBeRejected();
+    return;
+  }
+
+  gfx::Point root_location(point_.x(), point_.y());
+  root_window_.GetHost()->ConvertScreenInPixelsToDIP(&root_location);
+
+  target_window_ = root_window_.GetEventHandlerForPoint(root_location);
+  if (!target_window_)
+    return;
+
+  target_window_->AddObserver(this);
+
+  delegate_ = aura::client::GetDragDropDelegate(target_window_);
+  if (!delegate_)
+    return;
+
+  std::unique_ptr<ui::DropTargetEvent> event = CreateDropTargetEvent();
+  if (event) {
+    VLOG(1) << "Sending OnDragEntered to DragDropDelegate";
+    delegate_->OnDragEntered(*event);
+    delegate_->OnDragUpdated(*event) ?
+        IndicateDragWillBeAccepted() : IndicateDragWillBeRejected();
+
+    if (delayed_drop_location_) {
+      // The drop has already occurred, and should be reported immediately. In
+      // this case, the coordinates reported for the drop are actually from an
+      // earlier point in time than the coordinates reported for the drag enter,
+      // which is weird, but harmless: it's only important that the drop occur
+      // at the right place.
+      std::unique_ptr<ui::DropTargetEvent> delayedEvent =
+          CreateDropTargetEvent(*delayed_drop_location_.get());
+      delegate_->OnPerformDrop(*delayedEvent.get());
+      DragDropSessionCompleted();
+      delayed_drop_location_.reset();
+    }
+  }
+}
+
+std::unique_ptr<ui::DropTargetEvent>
+DesktopDragDropClientWayland::CreateDropTargetEvent(
+    const gfx::Point& root_location) const {
+  if (!target_window_)
+    return nullptr;
+
+  // TODO(mcatanzaro): The Wayland drag-and-drop protocol is not yet
+  // sufficiently advanced to allow specifying drag actions (move/copy/link),
+  // so we have no choice but to hardcode one drag action here.
+  // https://bugs.freedesktop.org/show_bug.cgi?id=91949
+  int drag_operations = ui::DragDropTypes::DRAG_COPY;
+
+  gfx::Point target_location = root_location;
+  target_window_->GetHost()->ConvertDIPToPixels(&target_location);
+  aura::Window::ConvertPointToTarget(&root_window_,
+                                     target_window_,
+                                     &target_location);
+
+  return std::unique_ptr<ui::DropTargetEvent>(new ui::DropTargetEvent(
+      data_collector_->GetData(),
+      target_location,
+      root_location,
+      drag_operations));
+}
+
+std::unique_ptr<ui::DropTargetEvent>
+DesktopDragDropClientWayland::CreateDropTargetEvent() const {
+  gfx::Point root_location(point_.x(), point_.y());
+  root_window_.GetHost()->ConvertScreenInPixelsToDIP(&root_location);
+
+  return CreateDropTargetEvent(root_location);
+}
+
+void DesktopDragDropClientWayland::DragDropSessionCompleted() {
+  serial_ = 0;
+  windowhandle_ = 0;
+  data_collector_ = nullptr;
+  if (target_window_) {
+    target_window_->RemoveObserver(this);
+    target_window_ = nullptr;
+  }
+}
+
+}  // namespace views
diff --git a/ui/views/widget/desktop_aura/desktop_drag_drop_client_wayland.h b/ui/views/widget/desktop_aura/desktop_drag_drop_client_wayland.h
new file mode 100644
index 0000000..317898e
--- /dev/null
+++ b/ui/views/widget/desktop_aura/desktop_drag_drop_client_wayland.h
@@ -0,0 +1,185 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_IMPL_DESKTOP_AURA_DESKTOP_DRAG_DROP_CLIENT_WAYLAND_H_
+#define OZONE_IMPL_DESKTOP_AURA_DESKTOP_DRAG_DROP_CLIENT_WAYLAND_H_
+
+#include <list>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "ui/aura/client/drag_drop_client.h"
+#include "ui/aura/client/drag_drop_delegate.h"
+#include "ui/aura/client/drag_drop_client.h"
+#include "ui/aura/window_observer.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/views/views_export.h"
+
+namespace ui {
+
+class PlatformWindow;
+
+}
+
+namespace views {
+
+class VIEWS_EXPORT DesktopDragDropClientWayland
+    : public aura::client::DragDropClient,
+      public aura::WindowObserver {
+ public:
+  explicit DesktopDragDropClientWayland(aura::Window* root_window,
+                                        ui::PlatformWindow* platform_window);
+  ~DesktopDragDropClientWayland() override;
+
+  // Overridden from aura::client::DragDropClient:
+  int StartDragAndDrop(const ui::OSExchangeData& data,
+                       aura::Window* root_window,
+                       aura::Window* source_window,
+                       const gfx::Point& root_location,
+                       int operation,
+                       ui::DragDropTypes::DragEventSource source) override;
+  void DragCancel() override;
+  bool IsDragDropInProgress() override;
+
+  // Overridden from void aura::WindowObserver:
+  void OnWindowDestroying(aura::Window* window) override;
+
+  // Events received via IPC from the WaylandDataSource in the GPU process.
+  void OnDragEnter(gfx::AcceleratedWidget windowhandle,
+                   float x,
+                   float y,
+                   const std::vector<std::string>& mime_types,
+                   uint32_t serial);
+  void OnDragDataReceived(int pipefd);
+  void OnDragLeave();
+  void OnDragMotion(float x, float y, uint32_t time);
+  void OnDragDrop();
+
+ private:
+  // Used to build up an OSExchangeDataProvider and pass it to the
+  // DragDropDelegate of the target window. This requires round-tripping between
+  // the browser process and the GPU process once for each type of data to be
+  // stored in the OSExchangeDataProvider. The GPU process will pass us a file
+  // descriptor to read the data from, then once the read has completed we will
+  // close the descriptor and indicate to the GPU process that it is safe to
+  // request the next file descriptor. This has to happen one-by-one because
+  // some Wayland clients (e.g. GTK+ applications) expect that after calling
+  // wl_data_offer_receive() (in the GPU process), we will drain the received
+  // file descriptor of all data and close it before calling
+  // wl_data_offer_receive() again. We could read from the pipe either
+  // asynchronously in the IO thread, or synchronously in the user-blocking file
+  // thread. The file thread was chosen for simplicity. Either way, a
+  // RefCountedThreadSafe container is required, since there is a very small
+  // window in which a DesktopDragDropClientWayland could theoretically be
+  // destroyed in the middle of an ongoing drag operation, and the drag could be
+  // cancelled before all data has been received. Note also that a
+  // DragDataCollector corresponds to exactly one outstanding drag-and-drop
+  // and should not be reused for a second drag-and-drop session.
+  class DragDataCollector
+      : public base::RefCountedThreadSafe<DragDataCollector>,
+        public base::SupportsWeakPtr<DragDataCollector> {
+   public:
+    DragDataCollector(
+        base::WeakPtr<DesktopDragDropClientWayland> drag_drop_client,
+        const std::vector<std::string>& mime_types,
+        gfx::AcceleratedWidget windowhandle);
+    // DragDropDataController assumes ownership of |pipefd| and will ensure it
+    // is closed exactly once.
+    void SetPipeFd(int pipefd);
+    int GetPipeFd() const { return pipefd_; }
+
+    std::string first_received_mime_type() const {
+      return first_received_mime_type_;
+    }
+
+    bool IsReadingData() const;
+    void HandleNextMimeType();
+
+    const ui::OSExchangeData& GetData() const { return os_exchange_data_; }
+
+    // Synchronously read drag-and-drop data from the source process.
+    static void ReadDragData(scoped_refptr<DragDataCollector>);
+   private:
+    friend class base::RefCountedThreadSafe<DragDataCollector>;
+    ~DragDataCollector();
+
+    // Returns the next MIME type to be received from the source process, or an
+    // empty string if there are no more interesting MIME types left to process.
+    std::string SelectNextMimeType();
+
+    base::WeakPtr<DesktopDragDropClientWayland> drag_drop_client_;
+    ui::OSExchangeData os_exchange_data_;
+    std::list<std::string> unprocessed_mime_types_;
+    std::string first_received_mime_type_;
+    int pipefd_ = 0;
+  };
+
+ public:
+  // Called by the DragDataCollector when all drag data has been received.
+  void OnDragDataCollected(DragDataCollector* collector);
+
+ private:
+  // Returns a DropTargetEvent to be passed to the DragDropDelegate, or null to
+  // abort the drag, using the location of point_ if no root location is passed.
+  std::unique_ptr<ui::DropTargetEvent> CreateDropTargetEvent(
+      const gfx::Point& point) const;
+  std::unique_ptr<ui::DropTargetEvent> CreateDropTargetEvent() const;
+
+  void DragDropSessionCompleted();
+
+  // Use to provide feedback to the source process on whether the drag will be
+  // accepted for the current coordinates and available mime types. This might
+  // be used to change the cursor, for example.
+  void IndicateDragWillBeAccepted();
+  void IndicateDragWillBeRejected();
+
+  // Valid between the start of a drag operation and when the process of reading
+  // drag-and-drop data from the source process has completed. No drag events
+  // can be sent to the DragDropDelegate until all data has been collected.
+  scoped_refptr<DragDataCollector> data_collector_;
+
+  // Unique identifier for the current drag.
+  uint32_t serial_ = 0;
+
+  // Window handle for active drag, or 0 if there is no active drag.
+  unsigned windowhandle_ = 0;
+
+  aura::Window& root_window_;
+  ui::PlatformWindow& platform_window_;
+
+  // Null unless all drag data has been received and the drag is unfinished.
+  aura::Window* target_window_;
+
+  // The most recent native coordinates of a drag.
+  gfx::Point point_;
+
+  // This is the interface that allows us to send drag events from Ozone-Wayland
+  // to the cross-platform code.
+  aura::client::DragDropDelegate* delegate_;
+
+  // The Wayland sends a drag leave event after a drag drop event, but the
+  // DragDropDelegate expects only one or the other. This is set to false after
+  // a successful drop to indicate that the drag leave event should not be
+  // passed on to the DragDropDelegate.
+  bool should_emit_drag_exited_ = true;
+
+  // Used to keep track of whether IndicateDragWillBeAccepted or
+  // IndicateDragWillBeRejected was most-recently called.
+  bool did_most_recently_accept_drag_ = false;
+
+  // Null except when a drop has occured but drag data is still being read.
+  std::unique_ptr<gfx::Point> delayed_drop_location_;
+
+  base::WeakPtrFactory<DesktopDragDropClientWayland> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(DesktopDragDropClientWayland);
+};
+
+}  // namespace views
+
+#endif  // OZONE_IMPL_DESKTOP_AURA_DESKTOP_DRAG_DROP_CLIENT_WAYLAND_H_
diff --git a/ui/views/widget/desktop_aura/desktop_factory_ozone_stubs.cc b/ui/views/widget/desktop_aura/desktop_factory_ozone_stubs.cc
new file mode 100644
index 0000000..65dee19
--- /dev/null
+++ b/ui/views/widget/desktop_aura/desktop_factory_ozone_stubs.cc
@@ -0,0 +1,17 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/widget/desktop_aura/desktop_factory_ozone_stubs.h"
+
+namespace views {
+
+DesktopFactoryOzone* CreateDesktopFactoryOzoneHeadless() {
+  return nullptr;
+}
+
+DesktopFactoryOzone* CreateDesktopFactoryOzoneEgltest() {
+  return nullptr;
+}
+
+}  // namespace views
diff --git a/ui/views/widget/desktop_aura/desktop_factory_ozone_stubs.h b/ui/views/widget/desktop_aura/desktop_factory_ozone_stubs.h
new file mode 100644
index 0000000..474f0f5
--- /dev/null
+++ b/ui/views/widget/desktop_aura/desktop_factory_ozone_stubs.h
@@ -0,0 +1,17 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_WIDGET_DESKTOP_AURA_DESKTOP_FACTORY_OZONE_STUBS_H
+#define UI_VIEWS_WIDGET_DESKTOP_AURA_DESKTOP_FACTORY_OZONE_STUBS_H
+
+#include "ui/views/widget/desktop_aura/desktop_factory_ozone.h"
+
+namespace views {
+
+DesktopFactoryOzone* CreateDesktopFactoryOzoneHeadless();
+DesktopFactoryOzone* CreateDesktopFactoryOzoneEgltest();
+
+}  // namespace views
+
+#endif // UI_VIEWS_WIDGET_DESKTOP_AURA_DESKTOP_FACTORY_OZONE_STUBS_H
diff --git a/ui/views/widget/desktop_aura/desktop_factory_ozone_wayland.cc b/ui/views/widget/desktop_aura/desktop_factory_ozone_wayland.cc
index b8f9386..ca57826e 100644
--- a/ui/views/widget/desktop_aura/desktop_factory_ozone_wayland.cc
+++ b/ui/views/widget/desktop_aura/desktop_factory_ozone_wayland.cc
@@ -3,17 +3,19 @@
 // found in the LICENSE file.
 
 #include "ui/views/widget/desktop_aura/desktop_factory_ozone_wayland.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host_ozone_wayland.h"
+#include "ui/views/widget/desktop_aura/desktop_screen_ozone_wayland.h"
 
 namespace views {
 
 DesktopWindowTreeHost* DesktopFactoryOzoneWayland::CreateWindowTreeHost(
     internal::NativeWidgetDelegate* native_widget_delegate,
     DesktopNativeWidgetAura* desktop_native_widget_aura) {
-  return nullptr;
+  return new DesktopWindowTreeHostOzone(native_widget_delegate, desktop_native_widget_aura);
 }
 
 display::Screen* DesktopFactoryOzoneWayland::CreateDesktopScreen() {
-  return nullptr;
+  return new DesktopScreenWayland;
 }
 
 DesktopFactoryOzone* CreateDesktopFactoryOzoneWayland() {
diff --git a/ui/views/widget/desktop_aura/desktop_screen_ozone_wayland.cc b/ui/views/widget/desktop_aura/desktop_screen_ozone_wayland.cc
new file mode 100644
index 0000000..0782a5d
--- /dev/null
+++ b/ui/views/widget/desktop_aura/desktop_screen_ozone_wayland.cc
@@ -0,0 +1,163 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/widget/desktop_aura/desktop_screen_ozone_wayland.h"
+
+//#include "ozone/platform/desktop_platform_screen.h"
+//#include "ozone/platform/ozone_platform_wayland.h"
+//#include "ozone/ui/desktop_aura/desktop_window_tree_host_ozone.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host_ozone_wayland.h"
+
+#include "ui/aura/window.h"
+#include "ui/views/widget/desktop_aura/desktop_screen.h"
+
+namespace views {
+
+DesktopScreenWayland::DesktopScreenWayland()
+    : display::Screen(),
+      rect_(0, 0, 0, 0),
+      displays_() {
+  // TODO(tonikitoo)
+  //platform_Screen_ = CreatePlatformScreen(this);
+  SetGeometry(gfx::Rect(0, 0, 1024, 640));
+}
+
+DesktopScreenWayland::~DesktopScreenWayland() {
+}
+
+void DesktopScreenWayland::SetGeometry(const gfx::Rect& geometry) {
+  rect_ = geometry;
+  int max_area = 0;
+  const display::Display* matching = NULL;
+  for (std::vector<display::Display>::const_iterator it = displays_.begin();
+       it != displays_.end(); ++it) {
+    gfx::Rect intersect = gfx::IntersectRects(it->bounds(), rect_);
+    int area = intersect.width() * intersect.height();
+    if (area > max_area) {
+      max_area = area;
+      matching = &*it;
+    }
+  }
+
+  if (!matching) {
+    std::vector<display::Display> old_displays = displays_;
+    displays_.push_back(display::Display(displays_.size(), rect_));
+    change_notifier_.NotifyDisplaysChanged(old_displays, displays_);
+  }
+}
+
+gfx::Point DesktopScreenWayland::GetCursorScreenPoint() {
+  return gfx::Point();
+  //return platform_Screen_->GetCursorScreenPoint();
+}
+
+bool DesktopScreenWayland::IsWindowUnderCursor(gfx::NativeWindow window) {
+  return GetWindowAtScreenPoint(GetCursorScreenPoint()) == window;
+}
+
+gfx::NativeWindow DesktopScreenWayland::GetWindowAtScreenPoint(
+    const gfx::Point& point) {
+  const std::vector<aura::Window*>& windows =
+      views::DesktopWindowTreeHostOzone::GetAllOpenWindows();
+  for (std::vector<aura::Window*>::const_iterator it = windows.begin();
+         it != windows.end(); ++it) {
+    if ((*it)->GetBoundsInScreen().Contains(point))
+      return *it;
+  }
+
+  return NULL;
+}
+
+int DesktopScreenWayland::GetNumDisplays() const {
+  return displays_.size();
+}
+
+const std::vector<display::Display>& DesktopScreenWayland::GetAllDisplays() const {
+  return displays_;
+}
+
+display::Display DesktopScreenWayland::GetDisplayNearestWindow(
+    gfx::NativeView window) const {
+  DCHECK(!rect_.IsEmpty());
+  if (displays_.size() == 1)
+    return displays_.front();
+  // Getting screen bounds here safely is hard.
+  //
+  // You'd think we'd be able to just call window->GetBoundsInScreen(), but we
+  // can't because |window| (and the associated RootWindow*) can be partially
+  // initialized at this point; RootWindow initializations call through into
+  // GetDisplayNearestWindow(). But the wayland resources are created before we
+  // create the aura::RootWindow. So we ask what the DRWH believes the
+  // window bounds are instead of going through the aura::Window's screen
+  // bounds.
+  aura::WindowTreeHost* host = window->GetHost();
+  if (host) {
+    DesktopWindowTreeHostOzone* rwh =
+        DesktopWindowTreeHostOzone::GetHostForAcceleratedWidget(
+            host->GetAcceleratedWidget());
+    if (rwh)
+      return GetDisplayMatching(rwh->GetBoundsInScreen());
+  }
+
+  return GetPrimaryDisplay();
+}
+
+display::Display DesktopScreenWayland::GetDisplayNearestPoint(
+    const gfx::Point& point) const {
+  if (displays_.size() == 1)
+    return displays_.front();
+
+  for (std::vector<display::Display>::const_iterator it = displays_.begin();
+         it != displays_.end(); ++it) {
+    if (it->bounds().Contains(point))
+      return *it;
+  }
+
+  return GetPrimaryDisplay();
+}
+
+display::Display DesktopScreenWayland::GetDisplayMatching(
+    const gfx::Rect& match_rect) const {
+  if (displays_.size() == 1)
+    return displays_.front();
+
+  DCHECK(!rect_.IsEmpty());
+  int max_area = 0;
+  const display::Display* matching = NULL;
+  for (std::vector<display::Display>::const_iterator it = displays_.begin();
+       it != displays_.end(); ++it) {
+    gfx::Rect intersect = gfx::IntersectRects(it->bounds(), match_rect);
+    int area = intersect.width() * intersect.height();
+    if (area > max_area) {
+      max_area = area;
+      matching = &*it;
+    }
+  }
+
+  // Fallback to the primary display if there is no matching display.
+  return matching ? *matching : GetPrimaryDisplay();
+}
+
+display::Display DesktopScreenWayland::GetPrimaryDisplay() const {
+  DCHECK(!rect_.IsEmpty());
+  return displays_.front();
+}
+
+void DesktopScreenWayland::AddObserver(display::DisplayObserver* observer) {
+  change_notifier_.AddObserver(observer);
+}
+
+void DesktopScreenWayland::RemoveObserver(display::DisplayObserver* observer) {
+  change_notifier_.RemoveObserver(observer);
+}
+
+#if 0
+// TODO(tonikitoo)
+void DesktopScreenWayland::OnOutputSizeChanged(unsigned width,
+                                               unsigned height) {
+  SetGeometry(gfx::Rect(0, 0, width, height));
+}
+#endif
+
+}  // namespace views
diff --git a/ui/views/widget/desktop_aura/desktop_screen_ozone_wayland.h b/ui/views/widget/desktop_aura/desktop_screen_ozone_wayland.h
new file mode 100644
index 0000000..112271b
--- /dev/null
+++ b/ui/views/widget/desktop_aura/desktop_screen_ozone_wayland.h
@@ -0,0 +1,68 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_IMPL_DESKTOP_AURA_DESKTOP_SCREEN_WAYLAND_H__
+#define OZONE_IMPL_DESKTOP_AURA_DESKTOP_SCREEN_WAYLAND_H__
+
+#include <memory>
+#include <vector>
+
+//#include "ozone/platform/desktop_platform_screen_delegate.h"
+#include "ui/display/display_change_notifier.h"
+#include "ui/display/display.h"
+#include "ui/display/screen.h"
+#include "ui/gfx/geometry/rect.h"
+
+namespace aura {
+class Window;
+}
+
+//namespace ui {
+//class DesktopPlatformScreen;
+//}
+
+namespace views {
+#if 0
+// TODO(tonikitoo)
+class DesktopScreenWayland : public gfx::Screen,
+                             public ui::DesktopPlatformScreenDelegate {
+#else
+class DesktopScreenWayland : public display::Screen {
+#endif
+ public:
+  DesktopScreenWayland();
+  ~DesktopScreenWayland() override;
+
+  // DesktopPlatformScreenDelegate overrides.
+#if 0
+  void OnOutputSizeChanged(unsigned width, unsigned height) override;
+#endif
+
+ private:
+  void SetGeometry(const gfx::Rect& geometry);
+  // Overridden from gfx::Screen:
+  gfx::Point GetCursorScreenPoint() override;
+  bool IsWindowUnderCursor(gfx::NativeWindow window) override;
+  gfx::NativeWindow GetWindowAtScreenPoint(const gfx::Point& point) override;
+  int GetNumDisplays() const override;
+  const std::vector<display::Display>& GetAllDisplays() const override;
+  display::Display GetDisplayNearestWindow(gfx::NativeView window) const override;
+  display::Display GetDisplayNearestPoint(const gfx::Point& point) const override;
+  display::Display GetDisplayMatching(const gfx::Rect& match_rect) const override;
+  display::Display GetPrimaryDisplay() const override;
+  void AddObserver(display::DisplayObserver* observer) override;
+  void RemoveObserver(display::DisplayObserver* observer) override;
+
+  gfx::Rect rect_;
+  display::DisplayChangeNotifier change_notifier_;
+
+  // The display objects we present to chrome.
+  std::vector<display::Display> displays_;
+  //std::unique_ptr<ui::DesktopPlatformScreen> platform_Screen_;
+  DISALLOW_COPY_AND_ASSIGN(DesktopScreenWayland);
+};
+
+}  // namespace views
+
+#endif  // OZONE_IMPL_DESKTOP_AURA_DESKTOP_SCREEN_WAYLAND_H__
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host_ozone_wayland.cc b/ui/views/widget/desktop_aura/desktop_window_tree_host_ozone_wayland.cc
new file mode 100644
index 0000000..f3478fb
--- /dev/null
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_ozone_wayland.cc
@@ -0,0 +1,1061 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host_ozone_wayland.h"
+
+#include <string>
+
+#include "base/bind.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "ui/aura/client/focus_client.h"
+#include "ui/aura/window_property.h"
+#include "ui/base/hit_test.h"
+#include "ui/base/ime/input_method.h"
+#include "ui/display/display.h"
+#include "ui/display/screen.h"
+#include "ui/events/platform/platform_event_source.h"
+#include "ui/gfx/geometry/insets.h"
+#include "ui/gfx/path.h"
+#include "ui/native_theme/native_theme.h"
+#include "ui/ozone/public/ozone_platform.h"
+#include "ui/platform_window/platform_window.h"
+#include "ui/views/corewm/tooltip_aura.h"
+#include "ui/views/linux_ui/linux_ui.h"
+#include "ui/views/views_delegate.h"
+#include "ui/views/views_export.h"
+#include "ui/views/widget/desktop_aura/desktop_drag_drop_client_wayland.h"
+// TODO(tonikitoo)
+//#include "ui/views/widget/desktop_aura/desktop_dispatcher_client.h"
+#include "ui/views/widget/desktop_aura/desktop_native_cursor_manager.h"
+#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
+#include "ui/views/widget/desktop_aura/desktop_screen_position_client.h"
+#include "ui/views/window/native_frame_view.h"
+#include "ui/wm/core/window_util.h"
+#include "ui/wm/public/window_move_client.h"
+
+DECLARE_WINDOW_PROPERTY_TYPE(views::DesktopWindowTreeHostOzone*);
+
+namespace views {
+
+std::list<gfx::AcceleratedWidget>*
+DesktopWindowTreeHostOzone::open_windows_ = NULL;
+
+std::vector<aura::Window*>*
+DesktopWindowTreeHostOzone::aura_windows_ = NULL;
+
+DEFINE_WINDOW_PROPERTY_KEY(
+    aura::Window*, kViewsWindowForRootWindow, NULL);
+
+DEFINE_WINDOW_PROPERTY_KEY(
+    DesktopWindowTreeHostOzone*, kHostForRootWindow, NULL);
+
+DesktopWindowTreeHostOzone::DesktopWindowTreeHostOzone(
+    internal::NativeWidgetDelegate* native_widget_delegate,
+    DesktopNativeWidgetAura* desktop_native_widget_aura)
+    : aura::WindowTreeHost(),
+      state_(Uninitialized),
+      has_capture_(false),
+      custom_window_shape_(false),
+      always_on_top_(false),
+      previous_bounds_(0, 0, 0, 0),
+      previous_maximize_bounds_(0, 0, 0, 0),
+      window_(0),
+      title_(base::string16()),
+      drag_drop_client_(NULL),
+      native_widget_delegate_(native_widget_delegate),
+      content_window_(NULL),
+      desktop_native_widget_aura_(desktop_native_widget_aura),
+      window_parent_(NULL),
+      window_children_(),
+      close_widget_factory_(this) {
+}
+
+DesktopWindowTreeHostOzone::~DesktopWindowTreeHostOzone() {
+  window()->ClearProperty(kHostForRootWindow);
+  aura::client::SetWindowMoveClient(window(), NULL);
+  desktop_native_widget_aura_->OnDesktopWindowTreeHostDestroyed(this);
+  DestroyDispatcher();
+}
+
+// static
+aura::Window*
+DesktopWindowTreeHostOzone::GetContentWindowForAcceleratedWidget(
+    gfx::AcceleratedWidget widget) {
+  aura::WindowTreeHost* host =
+      aura::WindowTreeHost::GetForAcceleratedWidget(widget);
+
+  return host ?
+      host->window()->GetProperty(kViewsWindowForRootWindow) : NULL;
+}
+
+// static
+DesktopWindowTreeHostOzone*
+DesktopWindowTreeHostOzone::GetHostForAcceleratedWidget(
+    gfx::AcceleratedWidget widget) {
+  aura::WindowTreeHost* host =
+      aura::WindowTreeHost::GetForAcceleratedWidget(widget);
+
+  return host ? host->window()->GetProperty(kHostForRootWindow) : NULL;
+}
+
+// static
+const std::vector<aura::Window*>&
+DesktopWindowTreeHostOzone::GetAllOpenWindows() {
+  if (!aura_windows_) {
+    const std::list<gfx::AcceleratedWidget>& windows = open_windows();
+    aura_windows_ = new std::vector<aura::Window*>(windows.size());
+    std::transform(
+        windows.begin(), windows.end(), aura_windows_->begin(),
+            DesktopWindowTreeHostOzone::GetContentWindowForAcceleratedWidget);
+    }
+
+  return *aura_windows_;
+}
+
+void DesktopWindowTreeHostOzone::CleanUpWindowList() {
+  delete open_windows_;
+  open_windows_ = NULL;
+  if (aura_windows_) {
+    aura_windows_->clear();
+    delete aura_windows_;
+    aura_windows_ = NULL;
+  }
+}
+
+gfx::Rect DesktopWindowTreeHostOzone::GetBoundsInScreen() const {
+  return platform_window_->GetBounds();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopWindowTreeHostOzone, DesktopWindowTreeHost implementation:
+
+void DesktopWindowTreeHostOzone::Init(
+    aura::Window* content_window,
+    const Widget::InitParams& params) {
+  content_window_ = content_window;
+  // In some situations, views tries to make a zero sized window, and that
+  // makes us crash. Make sure we have valid sizes.
+  Widget::InitParams sanitized_params = params;
+  if (sanitized_params.bounds.width() == 0)
+    sanitized_params.bounds.set_width(100);
+  if (sanitized_params.bounds.height() == 0)
+    sanitized_params.bounds.set_height(100);
+
+  InitOzoneWindow(sanitized_params);
+}
+
+void DesktopWindowTreeHostOzone::OnNativeWidgetCreated(
+    const Widget::InitParams& params) {
+  window()->SetProperty(kViewsWindowForRootWindow, content_window_);
+  window()->SetProperty(kHostForRootWindow, this);
+
+  // If we're given a parent, we need to mark ourselves as transient to another
+  // window. Otherwise activation gets screwy.
+  gfx::NativeView parent = params.parent;
+  if (!params.child && params.parent)
+    wm::AddTransientChild(parent, content_window_);
+
+  native_widget_delegate_->OnNativeWidgetCreated(true);
+  open_windows().push_back(window_);
+  if (aura_windows_) {
+    aura_windows_->clear();
+    delete aura_windows_;
+    aura_windows_ = NULL;
+  }
+}
+
+std::unique_ptr<corewm::Tooltip>
+DesktopWindowTreeHostOzone::CreateTooltip() {
+  return std::unique_ptr<views::corewm::Tooltip>(new views::corewm::TooltipAura);
+}
+
+std::unique_ptr<aura::client::DragDropClient>
+DesktopWindowTreeHostOzone::CreateDragDropClient(
+    DesktopNativeCursorManager* cursor_manager) {
+  drag_drop_client_ = new DesktopDragDropClientWayland(window(),
+                                                       platform_window_.get());
+  // TODO(tonikitoo): Miss a call to Init?
+  return base::WrapUnique(drag_drop_client_);
+}
+
+void DesktopWindowTreeHostOzone::Close() {
+  if (!close_widget_factory_.HasWeakPtrs()) {
+    // And we delay the close so that if we are called from an ATL callback,
+    // we don't destroy the window before the callback returned (as the caller
+    // may delete ourselves on destroy and the ATL callback would still
+    // dereference us when the callback returns).
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+        FROM_HERE, base::Bind(&DesktopWindowTreeHostOzone::CloseNow,
+                              close_widget_factory_.GetWeakPtr()));
+  }
+}
+
+void DesktopWindowTreeHostOzone::CloseNow() {
+  if (!window_)
+    return;
+
+  unsigned widgetId = window_;
+  ReleaseCapture();
+  native_widget_delegate_->OnNativeWidgetDestroying();
+
+  // If we have children, close them. Use a copy for iteration because they'll
+  // remove themselves.
+  std::set<DesktopWindowTreeHostOzone*> window_children_copy =
+      window_children_;
+  for (std::set<DesktopWindowTreeHostOzone*>::iterator it =
+           window_children_copy.begin(); it != window_children_copy.end();
+       ++it) {
+    (*it)->CloseNow();
+  }
+  DCHECK(window_children_.empty());
+
+  // If we have a parent, remove ourselves from its children list.
+  if (window_parent_) {
+    window_parent_->window_children_.erase(this);
+    window_parent_ = NULL;
+  }
+
+  // Destroy the compositor before destroying the window since shutdown
+  // may try to swap, and the swap without a window causes an error, which
+  // causes a crash with in-process renderer.
+  DestroyCompositor();
+
+  open_windows().remove(widgetId);
+  if (aura_windows_) {
+    aura_windows_->clear();
+    delete aura_windows_;
+    aura_windows_ = NULL;
+  }
+
+  // Actually free our native resources.
+  platform_window_->Close();
+  window_ = 0;
+  if (open_windows().empty())
+    CleanUpWindowList();
+
+  desktop_native_widget_aura_->OnHostClosed();
+}
+
+aura::WindowTreeHost* DesktopWindowTreeHostOzone::AsWindowTreeHost() {
+  return this;
+}
+
+void DesktopWindowTreeHostOzone::ShowWindowWithState(
+    ui::WindowShowState show_state) {
+  if (compositor())
+    compositor()->SetVisible(true);
+  state_ |= Visible;
+
+  switch (show_state) {
+    case ui::SHOW_STATE_NORMAL:
+      Activate();
+      break;
+    case ui::SHOW_STATE_MAXIMIZED:
+      Maximize();
+      break;
+    case ui::SHOW_STATE_MINIMIZED:
+      Minimize();
+      break;
+    case ui::SHOW_STATE_FULLSCREEN:
+      SetFullscreen(true);
+      break;
+    default:
+      break;
+  }
+
+  native_widget_delegate_->AsWidget()->SetInitialFocus(show_state);
+}
+
+void DesktopWindowTreeHostOzone::ShowMaximizedWithBounds(
+    const gfx::Rect& restored_bounds) {
+  ShowWindowWithState(ui::SHOW_STATE_MAXIMIZED);
+  previous_bounds_ = restored_bounds;
+}
+
+bool DesktopWindowTreeHostOzone::IsVisible() const {
+  return state_ & Visible;
+}
+
+void DesktopWindowTreeHostOzone::SetSize(const gfx::Size& requested_size) {
+  gfx::Size size_in_pixels = ToPixelRect(gfx::Rect(requested_size)).size();
+  size_in_pixels = AdjustSize(size_in_pixels);
+  gfx::Rect new_bounds = platform_window_->GetBounds();
+  new_bounds.set_size(size_in_pixels);
+  platform_window_->SetBounds(new_bounds);
+}
+
+void DesktopWindowTreeHostOzone::StackAbove(aura::Window* window) {
+}
+
+void DesktopWindowTreeHostOzone::StackAtTop() {
+}
+
+void DesktopWindowTreeHostOzone::CenterWindow(const gfx::Size& size) {
+  gfx::Size size_in_pixels = ToPixelRect(gfx::Rect(size)).size();
+  gfx::Rect parent_bounds_in_pixels = GetWorkAreaBoundsInScreen();
+
+  // If |window_|'s transient parent bounds are big enough to contain |size|,
+  // use them instead.
+  if (wm::GetTransientParent(content_window_)) {
+    gfx::Rect transient_parent_rect =
+        wm::GetTransientParent(content_window_)->GetBoundsInScreen();
+    if (transient_parent_rect.height() >= size.height() &&
+      transient_parent_rect.width() >= size.width()) {
+      parent_bounds_in_pixels = ToPixelRect(transient_parent_rect);
+    }
+  }
+
+  gfx::Rect window_bounds_in_pixels(
+      parent_bounds_in_pixels.x() +
+          (parent_bounds_in_pixels.width() - size_in_pixels.width()) / 2,
+      parent_bounds_in_pixels.y() +
+          (parent_bounds_in_pixels.height() - size_in_pixels.height()) / 2,
+      size_in_pixels.width(), size_in_pixels.height());
+  // Don't size the window bigger than the parent, otherwise the user may not be
+  // able to close or move it.
+  window_bounds_in_pixels.AdjustToFit(parent_bounds_in_pixels);
+
+  SetBoundsInPixels(window_bounds_in_pixels);
+}
+
+void DesktopWindowTreeHostOzone::GetWindowPlacement(
+    gfx::Rect* bounds,
+    ui::WindowShowState* show_state) const {
+  *bounds = GetRestoredBounds();
+
+  if (IsMinimized()) {
+    *show_state = ui::SHOW_STATE_MINIMIZED;
+  } else if (IsFullscreen()) {
+    *show_state = ui::SHOW_STATE_FULLSCREEN;
+  } else if (IsMaximized()) {
+    *show_state = ui::SHOW_STATE_MAXIMIZED;
+  } else if (!IsActive()) {
+    *show_state = ui::SHOW_STATE_INACTIVE;
+  } else {
+    *show_state = ui::SHOW_STATE_NORMAL;
+  }
+}
+
+gfx::Rect DesktopWindowTreeHostOzone::GetWindowBoundsInScreen() const {
+  return platform_window_->GetBounds();
+}
+
+gfx::Rect DesktopWindowTreeHostOzone::GetClientAreaBoundsInScreen() const {
+  // TODO(erg): The NativeWidgetAura version returns |bounds_|, claiming its
+  // needed for View::ConvertPointToScreen() to work
+  // correctly. DesktopWindowTreeHostWin::GetClientAreaBoundsInScreen() just
+  // asks windows what it thinks the client rect is.
+  //
+  // Attempts to calculate the rect by asking the NonClientFrameView what it
+  // thought its GetBoundsForClientView() were broke combobox drop down
+  // placement.
+  return platform_window_->GetBounds();
+}
+
+gfx::Rect DesktopWindowTreeHostOzone::GetRestoredBounds() const {
+  if (!previous_bounds_.IsEmpty())
+    return ToDIPRect(previous_bounds_);
+
+  return GetWindowBoundsInScreen();
+}
+
+gfx::Rect DesktopWindowTreeHostOzone::GetWorkAreaBoundsInScreen() const {
+  // TODO(kalyan): Take into account wm decorations. i.e Dock, panel etc.
+  display::Screen *screen = display::Screen::GetScreen();
+  if (!screen)
+    NOTREACHED() << "Unable to retrieve valid display::Screen";
+
+  display::Display display = screen->GetPrimaryDisplay();
+  return ToDIPRect(display.bounds());
+}
+
+void DesktopWindowTreeHostOzone::SetShape(std::unique_ptr<SkRegion> native_region) {
+  custom_window_shape_ = false;
+  gfx::Path window_mask;
+
+  if (native_region) {
+    gfx::Transform transform = GetRootTransform();
+    if (!transform.IsIdentity() && !native_region->isEmpty()) {
+      SkPath path_in_dip;
+      if (native_region->getBoundaryPath(&path_in_dip)) {
+        path_in_dip.transform(transform.matrix(), &window_mask);
+      }
+    }
+
+    custom_window_shape_ = true;
+  }
+
+  platform_window_->SetWindowShape(window_mask);
+}
+
+void DesktopWindowTreeHostOzone::Activate() {
+  if (state_ & Visible) {
+    OnActivationChanged(true);
+  }
+}
+
+void DesktopWindowTreeHostOzone::Deactivate() {
+  OnActivationChanged(false);
+}
+
+bool DesktopWindowTreeHostOzone::IsActive() const {
+  return state_ & Active;
+}
+
+void DesktopWindowTreeHostOzone::Maximize() {
+  if (state_ & Maximized)
+    return;
+
+  state_ |= Maximized;
+  state_ &= ~Minimized;
+  previous_bounds_ = platform_window_->GetBounds();
+  platform_window_->Maximize();
+  if (IsMinimized())
+    ShowWindowWithState(ui::SHOW_STATE_MAXIMIZED);
+}
+
+void DesktopWindowTreeHostOzone::Minimize() {
+  if (state_ & Minimized)
+    return;
+
+  state_ |= Minimized;
+  previous_bounds_ = platform_window_->GetBounds();
+  ReleaseCapture();
+  compositor()->SetVisible(false);
+  content_window_->Hide();
+  platform_window_->Minimize();
+  Relayout();
+}
+
+void DesktopWindowTreeHostOzone::Restore() {
+  state_ &= ~Maximized;
+  if (state_ & Minimized) {
+    content_window_->Show();
+    compositor()->SetVisible(true);
+  }
+
+  platform_window_->Restore();
+  platform_window_->SetBounds(previous_bounds_);
+  previous_bounds_ = gfx::Rect();
+  Relayout();
+  if (state_ & Minimized) {
+    state_ &= ~Minimized;
+    ShowWindow();
+  }
+}
+
+bool DesktopWindowTreeHostOzone::IsMaximized() const {
+  return !IsFullscreen() && (state_ & Maximized);
+}
+
+bool DesktopWindowTreeHostOzone::IsMinimized() const {
+  return state_ & Minimized;
+}
+
+bool DesktopWindowTreeHostOzone::HasCapture() const {
+  return has_capture_;
+}
+
+void DesktopWindowTreeHostOzone::SetAlwaysOnTop(bool always_on_top) {
+  always_on_top_ = always_on_top;
+}
+
+bool DesktopWindowTreeHostOzone::IsAlwaysOnTop() const {
+  return always_on_top_;
+}
+
+void DesktopWindowTreeHostOzone::SetVisibleOnAllWorkspaces(
+    bool always_visible) {
+  NOTIMPLEMENTED();
+}
+
+bool DesktopWindowTreeHostOzone::IsVisibleOnAllWorkspaces() const {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+bool DesktopWindowTreeHostOzone::SetWindowTitle(const base::string16& title) {
+  if (title.compare(title_)) {
+    platform_window_->SetTitle(title);
+    title_ = title;
+    return true;
+  }
+
+  return false;
+}
+
+void DesktopWindowTreeHostOzone::ClearNativeFocus() {
+  // This method is weird and misnamed. Instead of clearing the native focus,
+  // it sets the focus to our |content_window_|, which will trigger a cascade
+  // of focus changes into views.
+  if (content_window_ && aura::client::GetFocusClient(content_window_) &&
+      content_window_->Contains(
+          aura::client::GetFocusClient(content_window_)->GetFocusedWindow())) {
+    aura::client::GetFocusClient(content_window_)->FocusWindow(content_window_);
+  }
+}
+
+Widget::MoveLoopResult DesktopWindowTreeHostOzone::RunMoveLoop(
+    const gfx::Vector2d& drag_offset,
+    Widget::MoveLoopSource source,
+    Widget::MoveLoopEscapeBehavior escape_behavior) {
+  NOTIMPLEMENTED();
+  return Widget::MOVE_LOOP_SUCCESSFUL;
+}
+
+void DesktopWindowTreeHostOzone::EndMoveLoop() {
+  NOTIMPLEMENTED();
+}
+
+void DesktopWindowTreeHostOzone::SetVisibilityChangedAnimationsEnabled(
+    bool value) {
+  // Much like the previous NativeWidgetGtk, we don't have anything to do here.
+}
+
+NonClientFrameView* DesktopWindowTreeHostOzone::CreateNonClientFrameView() {
+  return ShouldUseNativeFrame()
+             ? new NativeFrameView(native_widget_delegate_->AsWidget())
+             : nullptr;
+}
+
+bool DesktopWindowTreeHostOzone::ShouldUseNativeFrame() const {
+  return false;
+}
+
+bool DesktopWindowTreeHostOzone::ShouldWindowContentsBeTransparent() const {
+  return false;
+}
+
+void DesktopWindowTreeHostOzone::FrameTypeChanged() {
+  Widget::FrameType new_type =
+    native_widget_delegate_->AsWidget()->frame_type();
+  if (new_type == Widget::FRAME_TYPE_DEFAULT) {
+    // The default is determined by Widget::InitParams::remove_standard_frame
+    // and does not change.
+    return;
+  }
+
+  // Replace the frame and layout the contents. Even though we don't have a
+  // swapable glass frame like on Windows, we still replace the frame because
+  // the button assets don't update otherwise.
+  native_widget_delegate_->AsWidget()->non_client_view()->UpdateFrame();
+}
+
+void DesktopWindowTreeHostOzone::SetFullscreen(bool fullscreen) {
+  if ((state_ & FullScreen) == fullscreen)
+    return;
+
+  if (fullscreen)
+    state_ |= FullScreen;
+  else
+    state_ &= ~FullScreen;
+
+  if (!(state_ & FullScreen)) {
+    if (state_ & Maximized) {
+      previous_bounds_ = previous_maximize_bounds_;
+      previous_maximize_bounds_ = gfx::Rect();
+      platform_window_->Maximize();
+    } else {
+      Restore();
+    }
+  } else {
+    if (state_ & Maximized)
+      previous_maximize_bounds_ = previous_bounds_;
+
+    previous_bounds_ = platform_window_->GetBounds();
+    platform_window_->ToggleFullscreen();
+  }
+
+  Relayout();
+}
+
+bool DesktopWindowTreeHostOzone::IsFullscreen() const {
+  return state_ & FullScreen;
+}
+
+void DesktopWindowTreeHostOzone::SetOpacity(float opacity) {
+  content_window_->layer()->SetOpacity(opacity);
+  platform_window_->SetOpacity(opacity);
+}
+
+void DesktopWindowTreeHostOzone::SetWindowIcons(
+    const gfx::ImageSkia& window_icon, const gfx::ImageSkia& app_icon) {
+  // TODO(erg):
+  NOTIMPLEMENTED();
+}
+
+void DesktopWindowTreeHostOzone::InitModalType(ui::ModalType modal_type) {
+  switch (modal_type) {
+    case ui::MODAL_TYPE_NONE:
+      break;
+    default:
+      // TODO(erg): Figure out under what situations |modal_type| isn't
+      // none. The comment in desktop_native_widget_aura.cc suggests that this
+      // is rare.
+      NOTIMPLEMENTED();
+  }
+}
+
+void DesktopWindowTreeHostOzone::FlashFrame(bool flash_frame) {
+  // TODO(erg):
+  NOTIMPLEMENTED();
+}
+
+bool DesktopWindowTreeHostOzone::IsAnimatingClosed() const {
+  return false;
+}
+
+bool DesktopWindowTreeHostOzone::IsTranslucentWindowOpacitySupported() const {
+  return false;
+}
+
+void DesktopWindowTreeHostOzone::SizeConstraintsChanged() {
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopWindowTreeHostOzone, aura::WindowTreeHost implementation:
+
+gfx::Transform DesktopWindowTreeHostOzone::GetRootTransform() const {
+  display::Display display = display::Screen::GetScreen()->GetPrimaryDisplay();
+  aura::Window* win = const_cast<aura::Window*>(window());
+  display = display::Screen::GetScreen()->GetDisplayNearestWindow(win);
+
+  float scale = display.device_scale_factor();
+  gfx::Transform transform;
+  transform.Scale(scale, scale);
+  return transform;
+}
+
+ui::EventSource* DesktopWindowTreeHostOzone::GetEventSource() {
+  return this;
+}
+
+gfx::AcceleratedWidget DesktopWindowTreeHostOzone::GetAcceleratedWidget() {
+  return window_;
+}
+
+void DesktopWindowTreeHostOzone::ShowImpl() {
+  if (state_ & Visible)
+    return;
+
+  ShowWindowWithState(ui::SHOW_STATE_NORMAL);
+  native_widget_delegate_->OnNativeWidgetVisibilityChanged(true);
+}
+
+void DesktopWindowTreeHostOzone::HideImpl() {
+  if (!(state_ & Visible))
+    return;
+
+  state_ &= ~Visible;
+  platform_window_->Hide();
+  native_widget_delegate_->OnNativeWidgetVisibilityChanged(false);
+}
+
+gfx::Rect DesktopWindowTreeHostOzone::GetBoundsInPixels() const {
+  return platform_window_->GetBounds();
+}
+
+void DesktopWindowTreeHostOzone::SetBoundsInPixels(
+    const gfx::Rect& requested_bounds) {
+  gfx::Rect bounds(requested_bounds.origin(),
+                   AdjustSize(requested_bounds.size()));
+  platform_window_->SetBounds(bounds);
+}
+
+gfx::Point DesktopWindowTreeHostOzone::GetLocationOnScreenInPixels() const {
+  return platform_window_->GetBounds().origin();
+}
+
+void DesktopWindowTreeHostOzone::SetCapture() {
+  if (has_capture_)
+    return;
+
+  has_capture_ = true;
+  platform_window_->SetCapture();
+}
+
+void DesktopWindowTreeHostOzone::ReleaseCapture() {
+  platform_window_->ReleaseCapture();
+  OnLostCapture();
+}
+
+void DesktopWindowTreeHostOzone::ShowWindow() {
+  ui::WindowShowState show_state = ui::SHOW_STATE_NORMAL;
+  if (IsMinimized()) {
+    show_state = ui::SHOW_STATE_MINIMIZED;
+  } else if (IsFullscreen()) {
+    show_state = ui::SHOW_STATE_FULLSCREEN;
+  } else if (IsMaximized()) {
+    show_state = ui::SHOW_STATE_MAXIMIZED;
+  } else if (!IsActive()) {
+    show_state = ui::SHOW_STATE_INACTIVE;
+  }
+
+  ShowWindowWithState(show_state);
+}
+
+void DesktopWindowTreeHostOzone::SetCursorNative(gfx::NativeCursor cursor) {
+  platform_window_->SetCursor(cursor.platform());
+}
+
+void DesktopWindowTreeHostOzone::MoveCursorToScreenLocationInPixels(
+    const gfx::Point& location) {
+  platform_window_->MoveCursorTo(location);
+}
+
+void DesktopWindowTreeHostOzone::OnCursorVisibilityChangedNative(bool show) {
+  // TODO(erg): Conditional on us enabling touch on desktop linux builds, do
+  // the same tap-to-click disabling here that chromeos does.
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// ui::PlatformWindowDelegate implementation:
+void DesktopWindowTreeHostOzone::OnBoundsChanged(
+    const gfx::Rect& new_bounds) {
+  // TODO(kalyan): Add support to check if origin has really changed.
+  native_widget_delegate_->AsWidget()->OnNativeWidgetMove();
+  OnHostResizedInPixels(new_bounds.size());
+  ResetWindowRegion();
+}
+
+void DesktopWindowTreeHostOzone::OnDamageRect(const gfx::Rect& damaged_rect) {
+  compositor()->ScheduleRedrawRect(damaged_rect);
+}
+
+void DesktopWindowTreeHostOzone::OnAcceleratedWidgetDestroyed() {
+  gfx::AcceleratedWidget window = compositor()->ReleaseAcceleratedWidget();
+  DCHECK_EQ(window, window_);
+  window_ = gfx::kNullAcceleratedWidget;
+}
+
+void DesktopWindowTreeHostOzone::OnActivationChanged(bool active) {
+  if (active == (state_ & Active))
+    return;
+
+  if (active) {
+    // Make sure the stacking order is correct. The activated window should be
+    // first one in list of open windows.
+    std::list<gfx::AcceleratedWidget>& windows = open_windows();
+    DCHECK(windows.size());
+    if (windows.front() != window_) {
+      windows.remove(window_);
+      windows.insert(windows.begin(), window_);
+    }
+
+    state_ |= Active;
+    OnHostActivated();
+  } else {
+    state_ &= ~Active;
+    ReleaseCapture();
+  }
+
+  desktop_native_widget_aura_->HandleActivationChanged(active);
+  native_widget_delegate_->AsWidget()->GetRootView()->SchedulePaint();
+}
+
+void DesktopWindowTreeHostOzone::OnDragEnter(
+    unsigned windowhandle,
+    float x,
+    float y,
+    const std::vector<std::string>& mime_types,
+    uint32_t serial) {
+  if (drag_drop_client_)
+    drag_drop_client_->OnDragEnter(windowhandle, x, y, mime_types, serial);
+}
+
+void DesktopWindowTreeHostOzone::OnDragDataReceived(int fd) {
+  if (drag_drop_client_)
+    drag_drop_client_->OnDragDataReceived(fd);
+  else
+    close(fd);
+}
+
+void DesktopWindowTreeHostOzone::OnDragLeave() {
+  if (drag_drop_client_)
+    drag_drop_client_->OnDragLeave();
+}
+
+void DesktopWindowTreeHostOzone::OnDragMotion(float x,
+                                              float y,
+                                              uint32_t time) {
+  if (drag_drop_client_)
+    drag_drop_client_->OnDragMotion(x, y, time);
+}
+
+void DesktopWindowTreeHostOzone::OnDragDrop() {
+  if (drag_drop_client_)
+    drag_drop_client_->OnDragDrop();
+}
+
+// TODO(tonikitoo)
+std::string DesktopWindowTreeHostOzone::GetWorkspace() const {
+  return std::string();
+}
+
+void DesktopWindowTreeHostOzone::OnLostCapture() {
+  OnHostLostWindowCapture();
+  has_capture_ = false;
+}
+
+void DesktopWindowTreeHostOzone::OnAcceleratedWidgetAvailable(
+      gfx::AcceleratedWidget widget,
+       float device_pixel_ratio) {
+  window_ = widget;
+  CreateCompositor();
+  WindowTreeHost::OnAcceleratedWidgetAvailable();
+}
+
+void DesktopWindowTreeHostOzone::OnCloseRequest() {
+  Close();
+}
+
+void DesktopWindowTreeHostOzone::OnClosed() {
+  CloseNow();
+}
+
+void DesktopWindowTreeHostOzone::OnWindowStateChanged(
+    ui::PlatformWindowState new_state) {
+  switch (new_state) {
+    case ui::PLATFORM_WINDOW_STATE_MAXIMIZED: {
+      if (state_ & Minimized) {
+        content_window_->Show();
+        compositor()->SetVisible(true);
+        state_ &= ~Minimized;
+      }
+      platform_window_->SetBounds(previous_bounds_);
+      previous_bounds_ = gfx::Rect();
+      Relayout();
+      break;
+    }
+    default:
+      break;
+  }
+}
+
+void DesktopWindowTreeHostOzone::DispatchEvent(ui::Event* event) {
+  switch (event->type()) {
+    case ui::ET_MOUSEWHEEL:
+    case ui::ET_MOUSE_RELEASED:
+    case ui::ET_MOUSE_MOVED:
+    case ui::ET_MOUSE_DRAGGED:
+    case ui::ET_MOUSE_PRESSED:
+    case ui::ET_MOUSE_ENTERED:
+    case ui::ET_MOUSE_EXITED: {
+      // In Windows, the native events sent to chrome are separated into client
+      // and non-client versions of events, which we record on our LocatedEvent
+      // structures. On Desktop Ozone, we emulate the concept of non-client.
+      // Before we pass this event to the cross platform event handling
+      // framework, we need to make sure it is appropriately marked as
+      // non-client if it's in the non client area, or otherwise, we can get
+      // into a state where the a window is set as the |mouse_pressed_handler_|
+      // in window_event_dispatcher.cc despite the mouse button being released.
+      //
+      // We can't do this later in the dispatch process because we share that
+      // with ash, and ash gets confused about event IS_NON_CLIENT-ness on
+      // events, since ash doesn't expect this bit to be set, because it's never
+      // been set before. (This works on ash on Windows because none of the
+      // mouse events on the ash desktop are clicking in what Windows considers
+      // to be a non client area.) Likewise, we won't want to do the following
+      // in any WindowTreeHost that hosts ash.
+      ui::MouseEvent* mouseev = static_cast<ui::MouseEvent*>(event);
+      if (content_window_ && content_window_->delegate()) {
+        int flags = mouseev->flags();
+        int hit_test_code =
+            content_window_->delegate()->GetNonClientComponent(
+                mouseev->location());
+        if (hit_test_code != HTCLIENT && hit_test_code != HTNOWHERE)
+          flags |= ui::EF_IS_NON_CLIENT;
+        mouseev->set_flags(flags);
+      }
+      break;
+    }
+    case ui::ET_KEY_PRESSED:
+    case ui::ET_KEY_RELEASED: {
+      GetInputMethod()->DispatchKeyEvent(static_cast<ui::KeyEvent*>(event));
+      break;
+    }
+
+    default:
+      break;
+  }
+
+  SendEventToProcessor(event);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopWindowTreeHostOzone, private:
+
+void DesktopWindowTreeHostOzone::InitOzoneWindow(
+    const Widget::InitParams& params) {
+  const gfx::Rect& bounds_in_pixels = ToPixelRect(params.bounds);
+  const gfx::Rect& bounds = gfx::Rect(bounds_in_pixels.origin(),
+                                      AdjustSize(bounds_in_pixels.size()));
+  platform_window_ =
+      ui::OzonePlatform::GetInstance()->CreatePlatformWindow(this, bounds);
+  DCHECK(window_);
+  // Maintain parent child relation as done in X11 version.
+  // If we have a parent, record the parent/child relationship. We use this
+  // data during destruction to make sure that when we try to close a parent
+  // window, we also destroy all child windows.
+  gfx::AcceleratedWidget parent_window = 0;
+  if (params.parent && params.parent->GetHost()) {
+    parent_window = params.parent->GetHost()->GetAcceleratedWidget();
+    window_parent_ = GetHostForAcceleratedWidget(parent_window);
+    DCHECK(window_parent_);
+    window_parent_->window_children_.insert(this);
+  }
+
+  ui::PlatformWindow::PlatformWindowType type =
+      ui::PlatformWindow::PLATFORM_WINDOW_UNKNOWN;
+  switch (params.type) {
+    case Widget::InitParams::TYPE_TOOLTIP: {
+      type = ui::PlatformWindow::PLATFORM_WINDOW_TYPE_TOOLTIP;
+      break;
+    }
+    case Widget::InitParams::TYPE_POPUP: {
+      type = ui::PlatformWindow::PLATFORM_WINDOW_TYPE_POPUP;
+      break;
+    }
+    case Widget::InitParams::TYPE_MENU: {
+      type = ui::PlatformWindow::PLATFORM_WINDOW_TYPE_MENU;
+      break;
+    }
+    case Widget::InitParams::TYPE_BUBBLE: {
+      type = ui::PlatformWindow::PLATFORM_WINDOW_TYPE_BUBBLE;
+      break;
+    }
+    case Widget::InitParams::TYPE_WINDOW: {
+      type = ui::PlatformWindow::PLATFORM_WINDOW_TYPE_WINDOW;
+      break;
+    }
+    case Widget::InitParams::TYPE_WINDOW_FRAMELESS: {
+      type = ui::PlatformWindow::PLATFORM_WINDOW_TYPE_WINDOW_FRAMELESS;
+      break;
+    }
+    default:
+      break;
+  }
+
+  platform_window_->InitPlatformWindow(type, parent_window);
+  // If we have a delegate which is providing a default window icon, use that
+  // icon.
+  gfx::ImageSkia* window_icon =
+      ViewsDelegate::GetInstance()
+          ? ViewsDelegate::GetInstance()->GetDefaultWindowIcon()
+          : NULL;
+  if (window_icon) {
+    SetWindowIcons(gfx::ImageSkia(), *window_icon);
+  }
+
+  if (params.keep_on_top)
+    always_on_top_ = true;
+}
+
+void DesktopWindowTreeHostOzone::Relayout() {
+  Widget* widget = native_widget_delegate_->AsWidget();
+  NonClientView* non_client_view = widget->non_client_view();
+  // non_client_view may be NULL, especially during creation.
+  if (non_client_view) {
+    non_client_view->client_view()->InvalidateLayout();
+    non_client_view->InvalidateLayout();
+  }
+  widget->GetRootView()->Layout();
+  ResetWindowRegion();
+}
+
+std::list<gfx::AcceleratedWidget>&
+DesktopWindowTreeHostOzone::open_windows() {
+  if (!open_windows_)
+    open_windows_ = new std::list<gfx::AcceleratedWidget>();
+
+  return *open_windows_;
+}
+
+gfx::Size DesktopWindowTreeHostOzone::AdjustSize(
+    const gfx::Size& requested_size_in_pixels) {
+  std::vector<display::Display> displays =
+      display::Screen::GetScreen()->GetAllDisplays();
+  // Compare against all monitor sizes. The window manager can move the window
+  // to whichever monitor it wants.
+  for (size_t i = 0; i < displays.size(); ++i) {
+    if (requested_size_in_pixels == displays[i].GetSizeInPixel()) {
+      return gfx::Size(requested_size_in_pixels.width() - 1,
+                       requested_size_in_pixels.height() - 1);
+    }
+  }
+
+  // Do not request a 0x0 window size.
+  gfx::Size size_in_pixels = requested_size_in_pixels;
+  size_in_pixels.SetToMax(gfx::Size(1, 1));
+  return size_in_pixels;
+}
+
+gfx::Rect DesktopWindowTreeHostOzone::ToDIPRect(
+    const gfx::Rect& rect_in_pixels) const {
+  gfx::RectF rect_in_dip = gfx::RectF(rect_in_pixels);
+  GetRootTransform().TransformRectReverse(&rect_in_dip);
+  return gfx::ToEnclosingRect(rect_in_dip);
+}
+
+gfx::Rect DesktopWindowTreeHostOzone::ToPixelRect(
+    const gfx::Rect& rect_in_dip) const {
+  gfx::RectF rect_in_pixels = gfx::RectF(rect_in_dip);
+  GetRootTransform().TransformRect(&rect_in_pixels);
+  return gfx::ToEnclosingRect(rect_in_pixels);
+}
+
+void DesktopWindowTreeHostOzone::ResetWindowRegion() {
+  if (custom_window_shape_)
+    return;
+
+  gfx::Path window_mask;
+  const gfx::Rect& bounds_in_pixels = platform_window_->GetBounds();
+  if (!IsMaximized() && !IsFullscreen()) {
+    views::Widget* widget = native_widget_delegate_->AsWidget();
+    if (widget->non_client_view()) {
+      // Some frame views define a custom (non-rectangular) window mask. If
+      // so, use it to define the window shape. If not, fall through.
+      widget->non_client_view()->GetWindowMask(bounds_in_pixels.size(),
+                                               &window_mask);
+    }
+  }
+
+  if (!window_mask.countPoints()) {
+    // TODO(kalyan): handle the case where window has system borders..
+    SkRect rect = { 0,
+                    0,
+                    SkIntToScalar(bounds_in_pixels.width()),
+                    SkIntToScalar(bounds_in_pixels.height()) };
+    window_mask.addRect(rect);
+  }
+
+  platform_window_->SetWindowShape(window_mask);
+}
+
+// static
+#if 0
+// TODO(tonikitoo)
+VIEWS_EXPORT ui::NativeTheme*
+DesktopWindowTreeHost::GetNativeTheme(aura::Window* window) {
+  const views::LinuxUI* linux_ui = views::LinuxUI::instance();
+  if (linux_ui) {
+    ui::NativeTheme* native_theme = linux_ui->GetNativeTheme(window);
+    if (native_theme)
+      return native_theme;
+  }
+
+  return ui::NativeTheme::GetInstanceForWeb();
+}
+
+DesktopWindowTreeHost* DesktopWindowTreeHost::Create(
+    internal::NativeWidgetDelegate* native_widget_delegate,
+    DesktopNativeWidgetAura* desktop_native_widget_aura) {
+  return new DesktopWindowTreeHostOzone(native_widget_delegate,
+                                        desktop_native_widget_aura);
+}
+#endif
+
+}  // namespace views
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host_ozone_wayland.h b/ui/views/widget/desktop_aura/desktop_window_tree_host_ozone_wayland.h
new file mode 100644
index 0000000..2017c9b
--- /dev/null
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_ozone_wayland.h
@@ -0,0 +1,228 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_WIDGET_DESKTOP_AURA_DESKTOP_WINDOW_TREE_HOST_OZONE_H_
+#define UI_VIEWS_WIDGET_DESKTOP_AURA_DESKTOP_WINDOW_TREE_HOST_OZONE_H_
+
+#include <list>
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+// TODO(tonikitoo)
+//#include "base/basictypes.h"
+
+#include "ui/aura/window_tree_host.h"
+#include "ui/platform_window/platform_window_delegate.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host.h"
+
+namespace ui {
+class PlatformWindow;
+}
+
+namespace views {
+
+namespace corewm {
+class Tooltip;
+}
+
+class DesktopDragDropClientWayland;
+
+class VIEWS_EXPORT DesktopWindowTreeHostOzone
+    : public DesktopWindowTreeHost,
+      public aura::WindowTreeHost,
+      public ui::PlatformWindowDelegate {
+ public:
+  DesktopWindowTreeHostOzone(
+      internal::NativeWidgetDelegate* native_widget_delegate,
+      DesktopNativeWidgetAura* desktop_native_widget_aura);
+  ~DesktopWindowTreeHostOzone() override;
+
+  // Accepts a opaque handle widget and returns associated aura::Window.
+  static aura::Window* GetContentWindowForAcceleratedWidget(
+      gfx::AcceleratedWidget widget);
+
+  // Accepts a opaque handle widget and returns associated
+  // DesktopWindowTreeHostOzone.
+  static DesktopWindowTreeHostOzone* GetHostForAcceleratedWidget(
+      gfx::AcceleratedWidget widget);
+
+  // Get all open top-level windows. This includes windows that may not be
+  // visible. This list is sorted in their stacking order, i.e. the first window
+  // is the topmost window.
+  static const std::vector<aura::Window*>& GetAllOpenWindows();
+
+  // Deallocates the internal list of open windows.
+  static void CleanUpWindowList();
+
+  // Returns window bounds. This is used by Screen to determine if a point
+  // belongs to a particular window.
+  gfx::Rect GetBoundsInScreen() const;
+
+ protected:
+  // Overridden from DesktopWindowTreeHost:
+  void Init(aura::Window* content_window,
+            const views::Widget::InitParams& params) override;
+  void OnNativeWidgetCreated(const views::Widget::InitParams& params) override;
+  std::unique_ptr<corewm::Tooltip> CreateTooltip() override;
+  std::unique_ptr<aura::client::DragDropClient> CreateDragDropClient(
+      DesktopNativeCursorManager* cursor_manager) override;
+  void Close() override;
+  void CloseNow() override;
+  aura::WindowTreeHost* AsWindowTreeHost() override;
+  void ShowWindowWithState(ui::WindowShowState show_state) override;
+  void ShowMaximizedWithBounds(const gfx::Rect& restored_bounds) override;
+  bool IsVisible() const override;
+  void SetSize(const gfx::Size& size) override;
+  void StackAbove(aura::Window* window) override;
+  void StackAtTop() override;
+  void CenterWindow(const gfx::Size& size) override;
+  void GetWindowPlacement(gfx::Rect* bounds,
+                          ui::WindowShowState* show_state) const override;
+  gfx::Rect GetWindowBoundsInScreen() const override;
+  gfx::Rect GetClientAreaBoundsInScreen() const override;
+  gfx::Rect GetRestoredBounds() const override;
+  gfx::Rect GetWorkAreaBoundsInScreen() const override;
+  void SetShape(std::unique_ptr<SkRegion> native_region) override;
+  void Activate() override;
+  void Deactivate() override;
+  bool IsActive() const override;
+  void Maximize() override;
+  void Minimize() override;
+  void Restore() override;
+  bool IsMaximized() const override;
+  bool IsMinimized() const override;
+  bool HasCapture() const override;
+  void SetAlwaysOnTop(bool always_on_top) override;
+  bool IsAlwaysOnTop() const override;
+  void SetVisibleOnAllWorkspaces(bool always_visible) override;
+  bool IsVisibleOnAllWorkspaces() const override;
+  bool SetWindowTitle(const base::string16& title) override;
+  void ClearNativeFocus() override;
+  views::Widget::MoveLoopResult RunMoveLoop(
+      const gfx::Vector2d& drag_offset,
+      views::Widget::MoveLoopSource source,
+      views::Widget::MoveLoopEscapeBehavior escape_behavior) override;
+  void EndMoveLoop() override;
+  void SetVisibilityChangedAnimationsEnabled(bool value) override;
+  NonClientFrameView* CreateNonClientFrameView() override;
+  bool ShouldUseNativeFrame() const override;
+  bool ShouldWindowContentsBeTransparent() const override;
+  void FrameTypeChanged() override;
+  void SetFullscreen(bool fullscreen) override;
+  bool IsFullscreen() const override;
+  void SetOpacity(float opacity) override;
+  void SetWindowIcons(const gfx::ImageSkia& window_icon,
+                      const gfx::ImageSkia& app_icon) override;
+  void InitModalType(ui::ModalType modal_type) override;
+  void FlashFrame(bool flash_frame) override;
+  bool IsAnimatingClosed() const override;
+  bool IsTranslucentWindowOpacitySupported() const override;
+  void SizeConstraintsChanged() override;
+
+  // Overridden from aura::WindowTreeHost:
+  gfx::Transform GetRootTransform() const override;
+  ui::EventSource* GetEventSource() override;
+  gfx::AcceleratedWidget GetAcceleratedWidget() override;
+  void ShowImpl() override;
+  void HideImpl() override;
+  gfx::Rect GetBoundsInPixels() const override;
+  void SetBoundsInPixels(const gfx::Rect& requested_bounds_in_pixels) override;
+  gfx::Point GetLocationOnScreenInPixels() const override;
+  void SetCapture() override;
+  void ReleaseCapture() override;
+  void SetCursorNative(gfx::NativeCursor cursor) override;
+  void MoveCursorToScreenLocationInPixels(
+      const gfx::Point& location) override;
+  void OnCursorVisibilityChangedNative(bool show) override;
+
+  // Overridden from ui::PlatformWindowDelegate:
+  void OnBoundsChanged(const gfx::Rect&) override;
+  void OnDamageRect(const gfx::Rect& damaged_region) override;
+  void DispatchEvent(ui::Event* event) override;
+  void OnCloseRequest() override;
+  void OnClosed() override;
+  void OnWindowStateChanged(ui::PlatformWindowState new_state) override;
+  void OnLostCapture() override;
+  void OnAcceleratedWidgetAvailable(gfx::AcceleratedWidget widget,
+                                    float device_pixel_ratio) override;
+  void OnAcceleratedWidgetDestroyed() override;
+  void OnActivationChanged(bool active) override;
+  void OnDragEnter(unsigned windowhandle,
+                   float x,
+                   float y,
+                   const std::vector<std::string>& mime_types,
+                   uint32_t serial) override;
+  void OnDragDataReceived(int fd) override;
+  void OnDragLeave() override;
+  void OnDragMotion(float x, float y, uint32_t time) override;
+  void OnDragDrop() override;
+
+  // TODO(tonikitoo)
+  std::string GetWorkspace() const override;
+
+ private:
+  enum {
+    Uninitialized = 0x00,
+    Visible = 0x01,  // Window is Visible.
+    FullScreen = 0x02,  // Window is in fullscreen mode.
+    Maximized = 0x04,  // Window is maximized,
+    Minimized = 0x08,  // Window is minimized.
+    Active = 0x10  // Window is Active.
+  };
+
+  typedef unsigned RootWindowState;
+
+  // Initializes our Ozone surface to draw on. This method performs all
+  // initialization related to talking to the Ozone server.
+  void InitOzoneWindow(const views::Widget::InitParams& params);
+
+  void Relayout();
+  gfx::Size AdjustSize(const gfx::Size& requested_size);
+  void ShowWindow();
+
+  static std::list<gfx::AcceleratedWidget>& open_windows();
+  gfx::Rect ToDIPRect(const gfx::Rect& rect_in_pixels) const;
+  gfx::Rect ToPixelRect(const gfx::Rect& rect_in_dip) const;
+  void ResetWindowRegion();
+
+  RootWindowState state_;
+  bool has_capture_;
+  bool custom_window_shape_;
+  bool always_on_top_;
+
+  // Original bounds of DRWH.
+  gfx::Rect previous_bounds_;
+  gfx::Rect previous_maximize_bounds_;
+  gfx::AcceleratedWidget window_;
+  base::string16 title_;
+
+  // Owned by DesktopNativeWidgetAura.
+  DesktopDragDropClientWayland* drag_drop_client_;
+  views::internal::NativeWidgetDelegate* native_widget_delegate_;
+  aura::Window* content_window_;
+
+  views::DesktopNativeWidgetAura* desktop_native_widget_aura_;
+  // We can optionally have a parent which can order us to close, or own
+  // children who we're responsible for closing when we CloseNow().
+  DesktopWindowTreeHostOzone* window_parent_;
+  std::set<DesktopWindowTreeHostOzone*> window_children_;
+
+  // Platform-specific part of this DesktopWindowTreeHost.
+  std::unique_ptr<ui::PlatformWindow> platform_window_;
+  base::WeakPtrFactory<DesktopWindowTreeHostOzone> close_widget_factory_;
+
+  // A list of all (top-level) windows that have been created but not yet
+  // destroyed.
+  static std::list<gfx::AcceleratedWidget>* open_windows_;
+  // List of all open aura::Window.
+  static std::vector<aura::Window*>* aura_windows_;
+  DISALLOW_COPY_AND_ASSIGN(DesktopWindowTreeHostOzone);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_WIDGET_DESKTOP_AURA_DESKTOP_WINDOW_TREE_HOST_OZONE_H_
-- 
2.7.4

